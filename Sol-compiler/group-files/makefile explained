This file contains information about how SOL makefiles works.

$(SRCDIR) holds the main directory where ALL source files are stored.
$(VPATH) stores all the (recursively) subdirectories sotred in $(SRCDIR).

During the process of building we must do these passages:
1) check for prerequisites: It is not granted that the current system where you want to build
	has all the programs required correctly installed. For exmaple it may lack of "flex" or "bison". For
	this very reason the makefiles first assures that the system has all the requisites. Doing this is simple:
	it calls the program "which <program_to_check>" and look at its result: if is 0 the system has the command
	named <program_to_check> otherwise it returns 1 (see man which).
	For this very reason if the check throws strange error is possible that you lack of "which" command
	or "echo" command. The makefile use a speciale syntax to recognized if a target rule is a program checking;
	the target rules MUST start with "check-" and then the name of the program. For example
	if you want to check "wc" command the rule will have to be named as:
		check-wc
	This method has another precondition: NO *.c, *.h, *.lex, *.yacc must be start with "check-".
	This prerequisistes checking is echoed to the stdout in blue.
2) file-system: since compiled files are stored in "bin/" directory we need to create this very directory.
	This target rule handle this part.
3) $(YACC_FILES): in this variable there are stored all the compiled file (*.o) that comes out from "*y" files. So the
	compiled files have their origin from a *.y file. Their compile toolchain has to be:
		*.y -> bison -> *.c -> $(CC) -> *.o
	NOTE: bison also generates automatically a header file (this file contains the list of token used) that is necessary to flex to compile. So
	all the $(YACC_FILES) must be executed before the $(FLEX_FILES) files ones. This is why $(YACC_FILES) comes before
	the $(FLEX_FILES). 
3) $(FLEX_FILES): in this variable there are stored all the compiled files (*.o) that comes out from "*.lex" files. So the
	compiled files have their origin from a *.lex file. Their compile toolchain has to be:
		*.lex -> flex -> *.c -> $(CC) -> *.o
	NOTE: flex also generates automatically a header file (this file contains a reference to yylex() and lexVal) that is necessary to other *.c file to be present. So
	all the $(FLEX_FILES) must be executed before the $(CC_FILES) files ones. This is why $(FLEX_FILES) comes before
	the $(CC_FILES).
4) $(CC_FILES): in this variable there are stored all the compiled files (*.o) that comes out from "*.c" files. So the
	compile files have their origine from a *.c file (and optionally also with his dual *.h). Their compile toolchain has to be:
		*.c -> $(CC) -> *.o
	Note that the toolchain does require the existence of all the header file/shared library used inside the *.c files. Since
	"lexical.h" (the file generated by lexical.lex) is used throughout tests and the parser, it is required to firstly run $(FLEX_FILES).
5) application:
	In the project there are a lot of executables (not the *.o, but real applications, applications you can run with ./<name_application> on bash).
	Since there are lot of them we can't just make all of them (and also because in a executable there must be only ONE main function).
	To solve this problem every main() function inside the project should be encircled with a #ifdef directive; for example:
	
	#ifdef LEXICAL_TEST
		int main(){
			//stuff here...
		}
	#endif 

	Why we do that? Bacause the makefile has a macro called "APPLICATION": this variable tells the makefile one directive to add inside
	every compiled object built. You can "make APPLICATION=LEXICAL_TEST" to create the executable for the lexical-test or
	you can call "make APPLICATION=MAIN" to create the executable holding the true compiler. Easy right?
	


********************** optional prerequisites ***************************

There are other commands that the makefile checks. Although they are not part of the build process it is always useful to check their presence:
in this way the developer knows what he can do and what he can't. For example the project use "doxygen" to handle code documentation, so the makefile
check the presence of this program to make sure you can generate documentation. A yellow string will be output during the make process if an optional
command is not present on the system: don't worry though since you will be able to perfectly compile the compiler even without those optional commands.
The check process is handled by "optional-check-%" rule. It does work exactly as "check-%" but it use a different prefix ("optional-check-", not "check-").
Also it uses a different meethod to check the existence of the program: if it were to use "@which <command> > /dev/null" an optional command not present
in the system would stop the make process. Since it is optional, this behaviour was not correct.


******************************* Understand bison and flex dependencies ********************************* 
	 
Let's understand more deeply how flex and bison work together:
	- bison decides what token used and how define them: this is why we need to generate token-definitions.h, header generated by bison;
	- when bison needs the next lexical token, it invoke yylex(), a function created by flex;
	- to work correctly, flex needs to know how bison has defined the token he use (i.e. '(' or TK_EQUAL). For this very reason, he needs
		to include "token-definition.h", the include that holds the definitions of the tokens.
	- yylex() returns a int value, according to the token table inside "token-definition.h". Optionally, it edit the value inside its global variable,
	lexVal. This variable is defined inside lexical.y: so it is owned by flex.
	- bison must know about this variable, so we need "extern LexVal lexVal" inside syntax.y: in this way bison can use
	the variable. At the moment bison has been called, lexical.lex hasn't even been compiled yet, so at that moment the compiler
	hasn't even started to generate the space memory allocated to the variable lexVal: even so, with the reserved word "extern", all the stuff
	works properly.

In summary syntax.c is the main program, while lexical.c is just a code that have to use the header generated by syntax.y and lend the use of its
variable lexVal to syntax.c